# -*- coding: utf-8 -*-
"""AIproject.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r75edBz_2dH9mMUKg_YEteiP23VhIc0g
"""

# -*- coding: utf-8 -*-

import pandas as pd
from numpy import *
from pylab import *
import matplotlib.pyplot as plt
import numpy as np
import io
import pylab, random

#use selenium to do web crawler from hko web side
!pip install selenium
!apt-get update 
!apt install chromium-chromedriver
# set options to be headless, ..
from selenium import webdriver
from bs4 import BeautifulSoup
import time
 
#PATH = "C:\Program Files (x86)\chromedriver.exe"
 
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument('--headless')
chrome_options.add_argument('--no-sandbox')
chrome_options.add_argument('--disable-dev-shm-usage')
wd = webdriver.Chrome('chromedriver',chrome_options=chrome_options)
driver =webdriver.Chrome('chromedriver',chrome_options=chrome_options)

Weatherinfo = {}
Weatherinfo['temperature'] = []
Weatherinfo['humidity'] = []
Weatherinfo['Cloud'] = []
Weatherinfo['Rainfall'] = []

for m in range(1, 11):
  driver.get("https://www.hko.gov.hk/en/cis/dailyExtract.htm?y=2021&m="+str(m))
  driver.execute_script("window.scrollTo(0,document.body.scrollHeight)")
  time.sleep(2)
  soup = BeautifulSoup(driver.page_source, 'html.parser')
  titles = soup.find_all('td', {'class': 'td1_normal_class'})
  for i in range(0, len(titles)-34,11):
    Weatherinfo['temperature'].append(titles[i+2].getText())
    Weatherinfo['humidity'].append(titles[i+5].getText())
    Weatherinfo['Cloud'].append(titles[i+6].getText())
    Weatherinfo['Rainfall'].append(titles[i+7].getText())
    
driver.quit()

#set line width
pylab.rcParams['lines.linewidth'] = 4
#set font size for titles 
pylab.rcParams['axes.titlesize'] = 20
#set font size for labels on axes
pylab.rcParams['axes.labelsize'] = 20
#set size of numbers on x-axis
pylab.rcParams['xtick.labelsize'] = 16
#set size of numbers on y-axis
pylab.rcParams['ytick.labelsize'] = 16
#set size of ticks on x-axis
pylab.rcParams['xtick.major.size'] = 7
#set size of ticks on y-axis
pylab.rcParams['ytick.major.size'] = 7
#set size of markers
pylab.rcParams['lines.markersize'] = 10
#set number of examples shown in legends
pylab.rcParams['legend.numpoints'] = 1

accur = 0.0
sens = 0.0
spec = 0.0
leng = 0
data = {}

def minkowskiDist(v1, v2, p):
    """Assumes v1 and v2 are equal-length arrays of numbers
       Returns Minkowski distance of order p between v1 and v2"""
    dist = 0.0
    for i in range(len(v1)):
      dist += abs(v1[i]-v2[i])**p

    return dist**(1/p)

class Passenger(object):
    featureNames = ('C1', 'C2', 'C3', 'temperature', 'humidity')
    def __init__(self, Cloud, temperature, humidity, rain):
        self.featureVec = [0, 0, Cloud, temperature, humidity]
        self.label = rain
    def distance(self, other):
        return minkowskiDist(self.featureVec, other.featureVec, 2)
    def getCloud(self):
        return self.featureVec[2]
    def getTemperature(self):
        return self.featureVec[3]
    def getHumidity(self):
        return self.featureVec[4]
    def getLabel(self):
        return self.label
        
def getWeatherData():
    global data
    data['Cloud'], data['temperature'] = [], []
    data['humidity'], data['rain'] = [], []
    data['rainnum'] = []
    for i in range(len(Weatherinfo['temperature'])):
        data['temperature'].append(float(Weatherinfo['temperature'][i]))
        data['humidity'].append(float(Weatherinfo['humidity'][i]))
        data['Cloud'].append(float(Weatherinfo['Cloud'][i]))
        if str(Weatherinfo['Rainfall'][i]) == "Trace" or float(Weatherinfo['Rainfall'][i]) == 0.0:
          data['rain'].append("Notrain")
          data['rainnum'].append(1.0)
        else:
          data['rain'].append("rain")
          data['rainnum'].append(2.0)
           
    return data
                
def buildTitanicExamples():
    data = getWeatherData()
    examples = []
    global leng
    for i in range(len(data['temperature'])):
        p = Passenger(data['Cloud'][i], data['temperature'][i],
                      data['humidity'][i], data['rain'][i])
        examples.append(p)
        leng += 1
    print('Finished processing', len(examples), 'passengers\n')    
    return examples

examples = buildTitanicExamples()


def findNearest(name, exampleSet, metric):
    for e in exampleSet:
        if e.getName() == name:
            example = e
            break
    curDist = None
    for e in exampleSet:
        if e.getName() != name:
            if curDist == None or\
               metric(example, e) < curDist:
                nearest = e
                curDist = metric(example, nearest)
    return nearest

def accuracy(truePos, falsePos, trueNeg, falseNeg):
    numerator = truePos + trueNeg
    denominator = truePos + trueNeg + falsePos + falseNeg
    return numerator/denominator

def sensitivity(truePos, falseNeg):
    try:
        return truePos/(truePos + falseNeg)
    except ZeroDivisionError:
        return float('nan')
    
def specificity(trueNeg, falsePos):
    try:
        return trueNeg/(trueNeg + falsePos)
    except ZeroDivisionError:
        return float('nan')
    
def posPredVal(truePos, falsePos):
    try:
        return truePos/(truePos + falsePos)
    except ZeroDivisionError:
        return float('nan')
    
def negPredVal(trueNeg, falseNeg):
    try:
        return trueNeg/(trueNeg + falseNeg)
    except ZeroDivisionError:
        return float('nan')
       
def getStats(truePos, falsePos, trueNeg, falseNeg, toPrint):
    global accur
    global sens
    global spec
    accur = 0.0
    accur = accuracy(truePos, falsePos, trueNeg, falseNeg)
    sens = sensitivity(truePos, falseNeg)
    spec = specificity(trueNeg, falsePos)
    ppv = posPredVal(truePos, falsePos)
    if toPrint:
        print(' Accuracy =', round(accur, 3))
        print(' Sensitivity =', round(sens, 3))
        print(' Specificity =', round(spec, 3))
        print(' Pos. Pred. Val. =', round(ppv, 3))
    return (accur, sens, spec, ppv)

def findKNearest(example, exampleSet, k):
    kNearest, distances = [], []
    #Build lists containing first k examples and their distances
    for i in range(k):
      kNearest.append(exampleSet[i])
      distances.append(example.distance(exampleSet[i]))

    maxDist = max(distances) #Get maximum distance
    #Look at examples not yet considered
    for e in exampleSet[k:]:
        dist = example.distance(e)
        if dist < maxDist:
            #replace farther neighbor by this one
            maxIndex = distances.index(maxDist)
            kNearest[maxIndex] = e
            distances[maxIndex] = dist
            maxDist = max(distances)      
    return kNearest, distances
    
def KNearestClassify(training, testSet, label, k):
    """Assumes training & testSet lists of examples, k an int
       Predicts whether each example in testSet has label
       Returns number of true positives, false positives,
          true negatives, and false negatives"""
    truePos, falsePos, trueNeg, falseNeg = 0, 0, 0, 0
    for testCase in testSet:
      nearest, distances = findKNearest(testCase, training, k)
        		
      numMatch = 0
      for i in range(len(nearest)):
          if nearest[i].getLabel() == label:
              numMatch += 1
      if numMatch > k //2: #guess label
          if testCase.getLabel() == label:
              truePos += 1
          else:
              falsePos += 1
      else: #guess not label
          if testCase.getLabel() != label:
              trueNeg += 1
          else:
              falseNeg += 1
    return truePos, falsePos, trueNeg, falseNeg

def split80_20(examples):
    sampleIndices = random.sample(range(len(examples)),
                                  len(examples)//5)
    trainingSet, testSet = [], []
    for i in range(len(examples)):
        if i in sampleIndices:
            testSet.append(examples[i])
        else:
            trainingSet.append(examples[i])
    return trainingSet, testSet
    
def randomSplits(examples, method, numSplits, toPrint):
    truePos, falsePos, trueNeg, falseNeg = 0, 0, 0, 0
    random.seed(0)
    for t in range(numSplits):
        trainingSet, testSet = split80_20(examples)
        results = method(trainingSet, testSet)
        truePos += results[0]
        falsePos += results[1]
        trueNeg += results[2]
        falseNeg += results[3]
    getStats(truePos/numSplits, falsePos/numSplits,
             trueNeg/numSplits, falseNeg/numSplits, toPrint)
    return truePos/numSplits, falsePos/numSplits,\
             trueNeg/numSplits, falseNeg/numSplits

def testK(k_range):
  for k in k_range:
    knn = lambda training, testSet:KNearestClassify(training, testSet, 'rain', k)
    randomSplits(examples, knn, numSplits, toPrint = False)
    k_impreciseness.append(1-accur)
  
  return k_impreciseness

def findBestK(k_impreciseness):
  bestK = 0
  for i in range(1, len(k_impreciseness)):
    if k_impreciseness[i] < k_impreciseness[bestK]:
      bestK = i
  print("The Best K value is: " , bestK)
  return bestK + 1

#knn = lambda training, testSet:KNearestClassify(training, testSet, 'rain', 3)
k_impreciseness = []
k_range = range(1,30)
numSplits = 10

plt.plot(k_range, testK(k_range))
plt.xlabel('Value of K for KNN')
plt.ylabel('impreciseness')
plt.show()

k = findBestK(k_impreciseness)

knn = lambda training, testSet:KNearestClassify(training, testSet, 'rain', k)


print('Average of', numSplits,
      '80/20 splits using KNN ')
truePos, falsePos, trueNeg, falseNeg =\
      randomSplits(examples, knn, numSplits, toPrint = True)


random.seed(0)
trainingSet, testSet = split80_20(examples)


plt.scatter(data['temperature'], data['humidity'])
model = np.poly1d(np.polyfit(data['temperature'], data['humidity'], 3)) # trend line calculation
trendLine = np.linspace(20, 31) # trend line calculation
#plt.plot(myline, model(trendLine),'r--') # plot trend
plt.title("Weather") # title
plt.xlabel("Temperature") # x label
plt.ylabel("Humidity") # y label
plt.show()

df = pd.DataFrame(data)
rain = df[df['rainnum']==2.0]
not_rain = df[df['rainnum']==1.0]
not_rain_plot = not_rain.plot.scatter(x="temperature", y="humidity", color = "DarkBlue", label = "Not Rain" )
rain.plot.scatter(x="temperature", y="humidity", color = "Red", label = "Rain", ax = not_rain_plot )